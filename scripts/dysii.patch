diff -Naur ./dysii-1.4.0/CMakeLists.txt Dependencies-Build/dysii-1.4.0/CMakeLists.txt
--- ./dysii-1.4.0/CMakeLists.txt	1970-01-01 00:00:00.000000000 +0000
+++ Dependencies-Build/dysii-1.4.0/CMakeLists.txt	2009-08-04 19:29:37.000000000 +0000
@@ -0,0 +1,37 @@
+cmake_minimum_required(VERSION 2.6)
+SET(CMAKE_VERBOSE_MAKEFILE)
+INCLUDE (CheckIncludeFiles)
+
+PROJECT(dysii)
+
+CHECK_INCLUDE_FILES(math.h HAVE_MATH_H)
+
+IF(NOT HAVE_MATH_H)
+    MESSAGE(FATAL_ERROR "You need to have math.h")
+ENDIF()
+
+find_path(GSL include/gsl lib/libgsl.a)
+find_path(MPI include/mpi.h lib/libmpi.la)
+find_path(BOOST include/boost/numeric/ublas/vector.h
+    include/boost/numeric/ublas/matrix.hpp 
+    include/boost/numeric/bindings/traits/ublas_vector.hpp
+    include/boost/numeric/bindings/traits/ublas_matrix.hpp
+    include/boost/serialization/serialization.hpp lib/boost/)
+
+AUX_SOURCE_DIRECTORY(src/indii/ml/aux SOURCES )
+AUX_SOURCE_DIRECTORY(src/indii/ml/data SOURCES )
+AUX_SOURCE_DIRECTORY(src/indii/ml/filter SOURCES )
+AUX_SOURCE_DIRECTORY(src/indii/ml/ode SOURCES )
+AUX_SOURCE_DIRECTORY(src/indii/ml/sde SOURCES )
+
+INCLUDE_DIRECTORIES(${GSL}/include ${MPI}/include ${BOOST}/include)
+
+ADD_LIBRARY(dysii STATIC ${SOURCES})
+
+INSTALL(TARGETS dysii LIBRARY ARCHIVE DESTINATION lib/)
+
+INSTALL(DIRECTORY src/indii DESTINATION include
+    FILES_MATCHING PATTERN "*.hpp")
+
+SET(dysii_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/src)
+SET(dysii_LIBRARY_DIRS ${CMAKE_CURRENT_SOURCE_DIR})
diff -Naur ./dysii-1.4.0/UseDysii.cmake Dependencies-Build/dysii-1.4.0/UseDysii.cmake
--- ./dysii-1.4.0/UseDysii.cmake	1970-01-01 00:00:00.000000000 +0000
+++ Dependencies-Build/dysii-1.4.0/UseDysii.cmake	2009-08-04 19:29:37.000000000 +0000
@@ -0,0 +1,16 @@
+#   This file will permit you to add dysii to your project using
+#   FIND_PACKAGE(dysii REQUIRED)
+#   INCLUDE(${dysii_include} ${dysii_lib})
+#
+
+if(NOT dysii_USE_FILE_INCLUDED)
+    set(dysii_USE_FILE_INCLUDED 1)
+
+    # Add include directories needed to use dysii.
+    include_directories(${dysii_INCLUDE_DIRS})
+
+    # Add link directories needed to use KWWidgets.
+    link_directories(${dysii_LIBRARY_DIRS})
+
+endif(NOT dysii_USE_FILE_INCLUDED)
+
diff -Naur ./dysii-1.4.0/src/indii/ml/filter/Filter.hpp Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/Filter.hpp
--- ./dysii-1.4.0/src/indii/ml/filter/Filter.hpp	2008-12-17 15:15:27.000000000 +0000
+++ Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/Filter.hpp	2009-08-04 23:01:07.000000000 +0000
@@ -3,6 +3,7 @@
 
 #include "../aux/vector.hpp"
 #include "../aux/GaussianPdf.hpp"
+#include "boost/serialization/serialization.hpp"
 
 namespace indii {
   namespace ml {
@@ -30,7 +31,7 @@
    * \f$\mathbf{x}_0\f$.
    */
   Filter(const P& p_x0);
-
+  
   /**
    * Destructor.
    */
@@ -97,6 +98,16 @@
    */
   P p_xtn_ytn;
 
+  /**
+   * Serialization
+   */
+  template< class Archive >
+  void serialize(Archive & ar, unsigned int verison)
+  {
+        ar & tn;
+        ar & p_xtn_ytn;
+  }
+  friend class boost::serialization::access;
 };
 
     }
diff -Naur ./dysii-1.4.0/src/indii/ml/filter/ParticleFilter.hpp Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/ParticleFilter.hpp
--- ./dysii-1.4.0/src/indii/ml/filter/ParticleFilter.hpp	2008-12-17 15:15:27.000000000 +0000
+++ Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/ParticleFilter.hpp	2009-08-05 17:28:50.000000000 +0000
@@ -8,6 +8,7 @@
 #include "ParticleResampler.hpp"
 #include "ParticleFilterModel.hpp"
 #include "StratifiedParticleResampler.hpp"
+#include "boost/serialization/base_object.hpp"
 
 namespace indii {
   namespace ml {
@@ -40,7 +41,7 @@
    */
   ParticleFilter(ParticleFilterModel<T>* model,
       indii::ml::aux::DiracMixturePdf& p_x0);
-
+  
   /**
    * Destructor.
    */
@@ -88,12 +89,24 @@
    */
   void resample(ParticleResampler* resampler);
 
-private:
+protected:
   /**
    * Model.
    */
   ParticleFilterModel<T>* model;
 
+  /**
+   * Serialization
+   */
+  template< class Archive >
+  void serialize(Archive & ar, unsigned int version)
+  {
+    ar & boost::serialization::base_object
+                <Filter<T, indii::ml::aux::DiracMixturePdf> >(*this);
+//    ar & model;
+  }
+  friend class boost::serialization::access;
+
 };
 
     }
@@ -107,114 +120,118 @@
 indii::ml::filter::ParticleFilter<T>::ParticleFilter(
     ParticleFilterModel<T>* model,
     indii::ml::aux::DiracMixturePdf& p_x0) :
-    Filter<T,indii::ml::aux::DiracMixturePdf>(p_x0), model(model) {
+    Filter<T,indii::ml::aux::DiracMixturePdf>(p_x0), model(model) 
+{
   //
 }
 
 template <class T>
-indii::ml::filter::ParticleFilter<T>::~ParticleFilter() {
+indii::ml::filter::ParticleFilter<T>::~ParticleFilter() 
+{
   //
 }
 
 template <class T>
 indii::ml::filter::ParticleFilterModel<T>*
-    indii::ml::filter::ParticleFilter<T>::getModel() {
+    indii::ml::filter::ParticleFilter<T>::getModel() 
+{
   return model;
 }
 
 template <class T>
-void indii::ml::filter::ParticleFilter<T>::filter(const T tnp1) {
+void indii::ml::filter::ParticleFilter<T>::filter(const T tnp1) 
+{
   namespace aux = indii::ml::aux;
 
   /* pre-condition */
   assert (tnp1 >= this->tn);
 
-  aux::DiracMixturePdf p_xtnp1_ytnp1(model->getStateSize());
-  aux::vector x(model->getStateSize());
-  double w;
   T delta = tnp1 - this->tn;
-  unsigned int i;
 
   /* filter */
-  for (i = 0; i < this->p_xtn_ytn.getSize(); i++) {
-    noalias(x) = model->transition(this->p_xtn_ytn.get(i), this->tn, delta);
-    w = this->p_xtn_ytn.getWeight(i);
-
-    p_xtnp1_ytnp1.add(x, w);
+  for (unsigned int i = 0; i < this->p_xtn_ytn.getSize(); i++) {
+    if(model->transition(this->p_xtn_ytn.get(i), this->tn, delta) < 0) {
+        this->p_xtn_ytn.setWeight(i, 0);
+      }
   }
 
+  /* Make the distribution dirty since values changed 
+   * and force an update of cumulative weights, and Normalise
+   * */
+  this->p_xtn_ytn.distributedNormalise();
+
   /* update state */
   this->tn = tnp1;
-  this->p_xtn_ytn = p_xtnp1_ytnp1;
 }
 
 template <class T>
-void indii::ml::filter::ParticleFilter<T>::filter(const aux::vector& ytn) {
-  aux::vector x(model->getStateSize());
-  aux::vector ws(this->p_xtn_ytn.getSize());
+void indii::ml::filter::ParticleFilter<T>::filter(const aux::vector& ytn) 
+{
   unsigned int i;
-  
+
+  /* Modify weights */
+  aux::vector weights = this->p_xtn_ytn.getWeights();
+
   /* filter */
   for (i = 0; i < this->p_xtn_ytn.getSize(); i++) {
-    noalias(x) = this->p_xtn_ytn.get(i);
-    ws(i) = this->p_xtn_ytn.getWeight(i) * model->weight(x, ytn);
+    weights[i] = this->p_xtn_ytn.getWeight(i) * 
+          model->weight(this->p_xtn_ytn.get(i), ytn);
   }
 
-  /* update state */
-  this->p_xtn_ytn.setWeights(ws);
+  /* Update Weights and Normalise*/
+  this->p_xtn_ytn.setWeights(weights);
+  this->p_xtn_ytn.distributedNormalise();
 }
 
 template <class T>
 void indii::ml::filter::ParticleFilter<T>::filter(const T tnp1,
-    const aux::vector& ytnp1) {
+    const aux::vector& ytnp1) 
+{
   namespace aux = indii::ml::aux;
   
   /* pre-condition */
   assert (tnp1 >= this->tn);
 
-  aux::DiracMixturePdf p_xtnp1_ytnp1(model->getStateSize());
-  aux::vector x(model->getStateSize());
-  double w;
   T delta = tnp1 - this->tn;
-  unsigned int i;
+  
+  /* Modify weights */
+  aux::vector weights = this->p_xtn_ytn.getWeights();
 
   /* filter */
-  for (i = 0; i < this->p_xtn_ytn.getSize(); i++) {
-    noalias(x) = model->transition(this->p_xtn_ytn.get(i), this->tn, delta);
-    w = this->p_xtn_ytn.getWeight(i) * model->weight(x, ytnp1);
-
-    p_xtnp1_ytnp1.add(x, w);
+  for (unsigned int i = 0; i < this->p_xtn_ytn.getSize(); i++) {
+    //move particle forward, and in case of error make the weight 0
+    if(model->transition(this->p_xtn_ytn.get(i), this->tn, delta) < 0)
+      weights[i] = 0;
+    else //weight particle based on sampling and previous weight
+      weights[i] = this->p_xtn_ytn.getWeight(i) * 
+            model->weight(this->p_xtn_ytn.get(i), ytnp1);
   }
 
   /* update state */
   this->tn = tnp1;
-  this->p_xtn_ytn = p_xtnp1_ytnp1;
+  
+  /* Update Weights and Normalise*/
+  this->p_xtn_ytn.setWeights(weights);
+  this->p_xtn_ytn.distributedNormalise();
 }
 
 template <class T>
-indii::ml::aux::DiracMixturePdf
-    indii::ml::filter::ParticleFilter<T>::measure() {
+indii::ml::aux::DiracMixturePdf indii::ml::filter::ParticleFilter<T>::measure() 
+{
   namespace aux = indii::ml::aux;
-
   unsigned int i;
-  StratifiedParticleResampler resampler;
-  aux::DiracMixturePdf resampled(resampler.resample(
-      this->getFilteredState()));
-
   aux::DiracMixturePdf p_ytn_xtn(model->getMeasurementSize());  
-  for (i = 0; i < resampled.getSize(); i++) {
-    p_ytn_xtn.add(model->measure(resampled.get(i)));
+  for (i = 0; i < this->p_xtn_ytn.getSize(); i++) {
+    p_ytn_xtn.add(model->measure(this->p_xtn_ytn.get(i)));
   }
 
   return p_ytn_xtn;
 }
 
 template <class T>
-void indii::ml::filter::ParticleFilter<T>::resample(
-    ParticleResampler* resampler) {
-  indii::ml::aux::DiracMixturePdf resampled(resampler->resample(
-      this->getFilteredState()));
-  this->setFilteredState(resampled);
+void indii::ml::filter::ParticleFilter<T>::resample(ParticleResampler* resampler) 
+{
+  this->setFilteredState( resampler->resample(this->getFilteredState()) );
 }
 
 #endif
diff -Naur ./dysii-1.4.0/src/indii/ml/filter/ParticleFilterModel.hpp Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/ParticleFilterModel.hpp
--- ./dysii-1.4.0/src/indii/ml/filter/ParticleFilterModel.hpp	2008-12-17 15:15:27.000000000 +0000
+++ Dependencies-Build/dysii-1.4.0/src/indii/ml/filter/ParticleFilterModel.hpp	2009-08-05 16:44:58.000000000 +0000
@@ -51,8 +51,7 @@
    * @return \f$f(\mathbf{s}, \mathbf{w}, \Delta t)\f$; propagation of
    * the particle through the transition function, with noise.
    */
-  virtual indii::ml::aux::vector transition(const indii::ml::aux::vector& s,
-      const T t, const T delta) = 0;
+  virtual int transition(indii::ml::aux::vector& s, const T t, const T delta) = 0;
 
   /**
    * Apply the measurement function to an individual particle.
